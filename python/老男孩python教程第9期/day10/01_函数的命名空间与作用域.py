#函数的进阶

##例子1：  【函数外部的变量，全局有效】
# a = 1
# def func():
#     print(a)
#
# func()

##例子2：【函数内部定义的变量，只在函数内部有效，全局无法调用】
# def func2():
#     a = 2
#
# func2()
# print(a)

'''
命名空间和作用域

命名空间有如下三种：
（1）内置命名空间：【python解释器】
    #就是python解释器启动就可以使用的名字存储在内置命名空间中；
        例如：print()、input()、list、tuple等；
    #内置的名字在启动解释器的时候就被加载进内存里；

（2）全局命名空间：【我们写的代码但不是函数中的代码】
    #是在程序从上到下被执行的过程之中依次被加载进内存的
    #放置了我们设置的所有变量名和函数名

（3）局部命名空间：【函数代码】
    #就是函数内部定义的变量名
    #当调用函数的时候，才会产生这个名称空间，随着函数执行的结束，这个命名空间就又消失了；

#在局部中：可以使用全局、内置命名空间中的变量；
#在全局中：可以使用内置命名空间中的变量，但是不能使用局部中的变量
在内置中：不能使用全局和局部的变量；

找变量名字的顺序：
#在正常情况下，直接使用内置的名字；
#当我们在全局定义了和内置名字空间中同名的名字时，会使用全局的名字；
#当我自己有的时候，我就不找我的上级要了；
#如果自己没有，就找上一级要，上级没有就再找上一级，如果内置的名字空间没有，就报错；
#多个函数拥有多个命名空间
'''

# def input():
#     print('in input now')
#
# def func():
#     input = 1
#     print(input)
#
# func()   ##函数的执行
# func     ##不加括号，函数的内存地址

#函数名()：---> 函数的调用；
#函数的内存地址()：---> 函数的调用



'''
作用域:
    全局作用域：--- 作用于全局,内置和全局名字空间中的名字都属于全局作用域；--globals()
    局部作用域：--- 作用于局部，局部名字空间中的名字属于局部作用域，如函数；--locals()

#对于不可变的数据类型（对于可变数据类型来说也是一样的，如：列表），在局部可以查看全局作用域中的变量，但是不能直接修改，
如果想要修改，需要在程序的一开始添加global声明；
#如果在一个局部（函数）内声明一个global变量，那么这个变量在局部的所有操作将对
全局的变量有效；
'''

##例子1
# a = 1
# def func():
#     # global a   ##使用global变量声明变量，可以使用
#     a = 2
#
# func()
# print(a)
#
# print(globals())
# print(locals())


##globals: 永远打印全局的名字；
##locals： 输出什么，根据locals所在的位置；


#例子2.1
# def func1(m):
#     m[0] = 20
#     print("修改列表中元素的值后，其内存地址为：%s" %id(m))
#
#     m = [4,5,6]
#     print("修改变量指向的列表对象后，其内存地址为：%s" %id(m))
#     return m
#
# L = [1,2,3]
# ##在执行函数前，打印L的内存地址
# print(id(L))    ##结果为：12531464
# ##执行函数
# print(func1(L))
# ##打印全局变量L的值
# print(L)      ##结果为：[20,2,3]
# ##打印全局变量L的内存地址
# print(id(L))   ##结果为：12531464

'''
从上题的测试例子看，m是形参，L是实际传入的参数，m[0] = 20修改的是传入列表参数L的元素的值（即L[0]），元素L[0]的值
是改变了，但是L这个变量指向的列表对象并没有改变（即对象内存地址并未改变），m = [4,5,6]该赋值语句，指向了新对象，
内存地址发生了改变，但是m是形参，且函数中局部作用域不影响全局，全局的L指向对象并未发生改变，所以结果为：[20,2,3]
'''